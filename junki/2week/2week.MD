# 3-tier
![image](https://github.com/user-attachments/assets/b936971e-039f-4a26-b4e0-c5c18c9b0c67)
![image (1)](https://github.com/user-attachments/assets/717998ac-1314-48ef-80af-e8aef33350c7)

> 3계층으로 나누어 별도의 논리적/물리적인 장치에 구축 및 운영하는 형태

## 프레젠테이션 계층
> 사용자가 마주하는 계층 - 주로 사용자 인터페이스 지원(GUI, FrontEnd) &rarr; 사용자 인터페이스와 관계없는 데이터를 처리하는 로직 포함 X
Web Server

## 어플리케이션 계층
> 요청되는 정보를 어떠한 규칙을 바탕으로 처리하고 가공하는 것 담당(동적 데이터)
미들웨어 or 백엔드 라고 불림
Java가 이 계층에 속함


## 데이터 계층
> 주로 DB와 DB에 접근하여 데이터를 읽거나 쓰는 것
DBMS가 이 계층에 해당
MySQL, Redis, MongoDB 등이 이 계층에 속함

## `3-tier` 
>클라이언트, 어플리케이션, 데이터 계층으로 서버를 모두 물리적으로 나누어 구성하는 방법
>&rarr; 각각의 계층에서 변화가 일어나더라도 서로 영향을 받지 않고 독립적 운영

### 장점
- 각 계층이 분리되어 있어 업무 분담 가능 &rarr; 업무 효율성 증가
- 여러 대의 서버로 나누어 각 계층이 동작 &rarr; 서버의 부하를 줄임

### 단점
- 1계층으로만 사용하는 것 대비 관리가 필요, 장애가 발생하는 포인트가 더 늘어날 수 있음
- 비용이 그 만큼 많이 발생하게 되므로 서비스 규모 및 사용자 증가에 따라 계층 구조를 설계 및 고려

# Web Server
```
웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠를 제공
```

## Static Pages(정적인 페이지)
- `Web Server` 는 파일 경로 이름을 받아와 경로와 일치하는 파일 반환
- 항상 __동일한 페이지__ 반환
- `css`, `html`, `javascript`, `image` 등

## 기능
- 정적인 컨텐츠 제공
- `WAS`를 거치지 않고 바로 자원 제공
- 동적인 컨텐츠 제공을 위한 __요청 전달__
- 클라이언트의 요청을 `WAS`에 보내고, `WAS`가 처리한 결과를 클라이언트에게 전달(응답)
- ex) 회사 홈페이지, 블로그, 뉴스 사이트 등


# Web Application Server(WAS)
```
DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공
웹 애플리케이션 실행 및 데이터 처리, 웹 서버와 클라이언트 간 중계 역할
```
- 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓으면 자원의 낭비가 심하기 때문에 동적으로 전달해 줄 필요가 있음
- `WAS`를 통해 요청에 맞는 데이터를 가져와서 비즈니스 로직에 맞게 결과를 만들어 제공함으로써 자원을 효율적으로 사용
- 정적 컨텐츠를 처리할 수는 있지만 부하가 커지게 되고, 동적 컨텐츠의 처리가 지연되어 수행 속도가 느려짐

## Dynamic Pages(동적인 페이지)
- 인자의 내용에 맞게 동적인 내용들 반환
- `Web Server`에 의해 실행되는 프로그램을 통해 만들어진 결과물

## 기능
- 프로그램 실행 환경과 DB 접속 기능 제공
- 여러개의 트랜잭션 관리
- 비즈니스 로직 수행




# nginx
>open source webserver 및 reverse proxy server software로, 고성능 및 확장 가능한 웹 응용 프로그램을 제공하기 위해 설계된 소프트웨어

>apach Http server와 함께 가장 많이 사용되는 "웹서버"

## `nginx`를 사용하는 이유

### 높은 성능, 적은 메모리
> 비동기 I/O 처리 방식을 사용하여 높은 성능 제공 &rarr; 대규모 웹 사이트에서도 빠른 응답 시간 보장
적은 메모리 사용 &rarr; 서버 비용 절약

### 데이터 압축
> 클라이언트가 보내는 요청이 Text일 경우 gzip을 사용하여 해당 데이터 압축

### 비동기 처리
> __이벤트 루프 방식__ 을 사용해 높은 성능 제공 &rarr; 여러 요청이 들어왔을 때 많은 트래픽을 동시에 처리하여 빠른 응답시간 보장

### 리버스 프록시
- `forward proxy(정방향 프록시)` : `사용자`들이 사이트에 접속할 때 ip주소를 숨기기 위해 중간에 `프록시`를 두어 데이터를 주고받는 것 
![image (2)](https://github.com/user-attachments/assets/778221bd-4364-4f39-b08d-8b3af1e434db)

> 주 당국 또는 기관의 검색 제한을 피하기 위해
> 특정 컨텐츠에 대한 엑세스 차단
> 자신의 신원 보호


- `reverse proxy(역방향 프록시)` : 손님들에게서 `서버`의 정보를 숨김 &rarr; 서버 내부적으로 파일이 어디에 들어있는지, 서비스가 몇 번 포트로 돌고 있는지 등을 감춤
![image (3)](https://github.com/user-attachments/assets/fe824c2e-4bd5-428a-9925-44c00ba06e51)
> 하나 이상의 웹 서버 앞에 위치하여 클라이언트의 요청을 가로채는 서버
>> 어떤 클라이언트도 원본 서버와 직접 통신하지 못 하도록 막음

### 리버스 프록시의 이점

#### 로드 밸런싱
```
많은 사용자가 있는 서버의 경우 단일 원본 서버로 들어오는 모든 트래픽을 처리하지 못할 수 있음
동일한 사이트에 대한 요청을 서로 다른 서버 풀에 분산
```
- 많은 트래픽을 대처하는 방법
1. Scale Up : 기존 서버의 성능을 높임 &rarr; 비용도 올라감
2. Scale Out : 여러대의 서버를 두어 __트래픽 분산__ &rarr; `로드 밸런싱`

#### 공격으로부터 보호
```
원본 서버의 IP 주소를 공개할 필요가 없음 -> 공격하기 어려움
```

#### 전역 서버 부하 분산
```
웹 사이트는 전 세계 여러 서버에 분산 가능
클라이언트를 지리적으로 가장 가까운 서버로 보냄 -> 요청과 응답이 이동하는 거리가 줄어 로드 시간 최소화
```

#### 캐싱 
```
한 번 연결하고 난 후 응답데이터를 캐싱할 수 있음. 다음 사용자는 리버스 프록시 서버에서 캐시된 데이터를 가져오기 때문에 성능이 빨라짐
```

#### SSL 암호화
```
각 클라이언트에 대한 SSL통신의 암호화 및 암호 해독은 원본 서버의 경우 계산 비용이 많이 들 수 있음
리버스 프록시를 통해 모든 요청을 해독하고 나가는 모든 응답을 암호화하여 원본 서버의 리소스 확보
```

[얄팍한 코딩사전](https://www.youtube.com/watch?v=Zimhvf2B7Es)
[Nginx란 무엇인가?](https://blog.naver.com/gi_balja/223028077537)
[Nginx에 대하여](https://velog.io/@yange/nginx%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC)

## Apache vs Nginx
### Apache
> 스레드/프로세스 기반의 구조
http 요청이 올때마다 스레드나 프로세스를 새로 만들기 때문에 많은 수의 사용자가 동시 접속을 할 수록 CPI 부하가 높아짐 &rarr; 동시에 연결된 커넥션이 10,000개 이상이 되면 하드웨어 성능과 관계없이 서버가 더 이상의 커넥션을 형성하지 못하는, __C10K__ 문제 발생

### Nginx
```
비동기 이벤트 기반의 구조
더 적은 리소스로 처리 가능
```

>비동기 처리 : 작업이 서로 독립적으로 실행되어, 한 작업이 완료될 때까지 다른 작업이 중단되지 않고 계속 진행되는 방식

# Tomcat
>위에서 말한 `WAS(Web Application Server)`의 한 종류
>>동적인 웹을 만들기 위한 웹 컨테이너, 서블릿 컨테이너라고 불림
정적으로 처리해야할 데이터를 제외하고는 톰캣에게 전달
동적인 데이터 처리 가능, DB연결, 데이터 조작, 다른 응용프로그램과 상호 작용
Java EE 기반

- __8080 포트__ 로 처리
- `서블릿 컨테이너` 역할
	- `서블릿 컨테이너` : HTTP 요청을 받아 웹 페이지를 동적으로 생성
    - `컨테이너` : 동적인 데이터를 받아 가공하여 정적인 파일(HTML)로 만드는 것
    - `서블릿` : 클라이언트의 요청을 받아 처리하고, 그 결과를 클라이언트에게 제공하는 자바 인터페이스
- `Spring Boot` 는 __내장 `tomcat`__ 을 가지고 있음 
    - `jar` : `tomcat`이 내장된 빌드 파일
    - `war` : `tomcat`이 내장되지 않은 빌드 파일 &rarr; 다른 `WAS` 연결 가능
    
    
# jenkins
> `CI`/`CD`를 위한 오픈 소스 도구로, 소프트웨어 개발 생명주기 자동화
소프트웨어 개발 시 __지속적 통합 서비스__ 를 제공하는 툴

## CI/CD
> 개발자들이 동시에 작업한 코드 변경 사항을 통합하고, 이를 실제 환경에 지속적으로 배포하는 프로세스

`CI` : Continuous Integration - 지속적 통합 &rarr; 개발자들이 작성한 코드를 중앙 저장소에 자주 통합하고, 자동화된 빌드와 테스트를 통해 문제를 빠르게 발견하고 해결하는 것 -> 서로의 코드와 충돌 없이 효율적으로 협업

`CD` : Continuous Deployment - 지속적 배포 &rarr; 모든 변경사항을 자동화된 테스트와 빌드를 거친 후, 실제 사용자에게 자동 배포 -> 새로운 기능이나 수정사항을 빠르게 사용자에게 제공



## 개념

`jenkins`를 사용하여 코드 변경 사항이 발생할 때마다 자동으로 빌드, 테스트, 배포 과정 수행 가능
&rarr; 코드 변경에 따른 빌드 및 테스트 과정을 수동으로 수행할 필요가 없어지며, 신속하게 개발에 대한 코드 검증 및 배포 가능, 휴먼 에러 방지

개인이 확인하지 못한 코드 표준 준수 여부의 검사나 정적 분석을 통한 __코드 품질 검사__를 빌드 내부에서 수행

## 특징
> __마스터-슬레이브__ 아키텍처

- `마스터` 노드 : `controller` 라고 불리며, `슬레이브`를 관리하고 __작업 스케줄링__과 __모니터링__ 을 포함하여 다양한 작업 관리 &rarr; 작업 관리, 스케줄링, 플러그인 관리
- `슬레이브` 노드 : `agent` 라고 불리며, 실제 파이프라인 작업 수행. 다양한 환경에서 작동, 작업을 분산시켜 부하 감소 &rarr; 실제 빌드 및 테스트 작업


![image (4)](https://github.com/user-attachments/assets/6f8e4791-eb12-4e68-ac1a-048afbfb6b20)

### SCM(Source Code Management)
``` 코드가 보관되어 있는 git 저장소에 코드 변경사항을 감지하여 자동으로 파이프라인 수행```

### CI(Continuous Integeration)
``` 파이프라인이 실행되면 `Agent(Slave)`를 통해 파이프라인 스크립트에 정의된 작업 실행
&rarr; 소스 코드 빌드, 코드 검증 테스트 등 여러 작업 순차 진행```

### CD(Continuous Deployment)
``` 파이프라인에서 정의한 배포 작업에 따라 애플리케이션 배포```

## Jenkins 뜯어보기

우리 동아리에서 운영하는 프로젝트의 `Jenkins`를 한 번 보자

![image (5)](https://github.com/user-attachments/assets/cfabd953-203f-4a48-9b1f-bf171057517f)
그냥 설명하는 부분이다
GitHub 링크를 연결해준다

![image (6)](https://github.com/user-attachments/assets/4825f21e-c73b-4286-be36-3b8523512ada)
몇 개의 빌드를 저장할 지 선택할 수 있다 
이걸 통해서 롤백을 하는 것 같다


`SCM` 부분이다

`Repository URL`에 있는 Git 프로젝트에 접근을 한다
`Credentials`은 해당 프로젝트에 접근할 때 필요한 인증 정보를 넣어놓는 곳이다
`Branches to build` 에 있는 브랜치에 체크아웃하여 빌드를 진행한다

![image (8)](https://github.com/user-attachments/assets/db74465d-177f-4712-9b95-77ae8267c183)
![image (9)](https://github.com/user-attachments/assets/7391c3c8-841d-4960-84d0-0253643372c5)
다음은 빌드환경이다 

`SSH 서버`의 이름을 지정해주고, Transfer 부분에서 설정을 해준다
`Source files` 을 통해서 전송할 파일이나 디렉토리의 경로를 정해준다
`Remove prefix`를 통해서 전송할 파일의 경로에서 제거할 접두사를 정해준다
`Remote directory` 를 통해서 파일을 전송한 원격 서버의 디렉토리를 정해준다
`Exec command`를 통해서 파일을 전송한 후 원격 서버에서 실행할 명령을 정해준다


## Jenkins 빌드 과정
### 빌드 트리거
`Jenkins`가 빌드를 트리거 &rarr; 수동으로 시작하거나 트리거를 통해 시작

### 소스 코드 체크아웃
`Repository URL`에 설정된 Git에서 최신 소스 코드에 체크아웃

### 프로젝트 빌드
빌드 도구를 사용하여 프로젝트 빌드 &rarr; `.jar` 파일 생성

### 파일 전송
빌드가 성공하면 설정된 `SSH 서버`로 빌드 아티팩트 전송 &rarr; 코인에서는 `KOIN_API_V2.jar` 파일을 `koin_api_v2` 디렉토리에 전송

### 명령 실행
파일 전송 후 `Exec command`에 있는 명령 실행 
