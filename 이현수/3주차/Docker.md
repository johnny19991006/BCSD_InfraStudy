# 도커

## 컨테이너
### 컨테이너의 정의
>
소프트웨어 서비스를 실행하는 데 필요한 특정 버전의 프로그래밍 언어, 런타임 및 라이브러리와 같은 종속 항목과 애플리케이션 코드를 함께 포함하는 경량 패키지

### 컨테이너 동작 원리
- 컨테이너에는 OS가 없기 때문에 호스트OS의 커널을 사용하여 동작한다.
- 호스트OS를 공유하기 때문에 호스트 시스템에서도 컨테이너 내부의 프로세스를 볼 수 있다. 즉, MySQL을 도커 컨테이너로 시작한다면 도커가 아닌 호스트의 일반 셸에서 `ps-e |grep MySQL`로 MySQL 프로세스를 발견할 수 있다.
- 리눅스 커널의 Cgroup(control groups)과 네임스페이스 기능을 이용해서 다른 프로세스 사이에 벽을 만들어 독립된 공간을 제공한다.

### 도커는 리눅스 기반, 그렇다면 리눅스가 아닌 OS에서는?

>![image.png](https://i.imgur.com/dh12Cf9.png)

- Docker Engine(VM)을 이용하여 가상 리눅스 환경을 실행
- Docker Engine의 리눅스 위에서 컨테이너를 실행한다.
- Docker 는 그 자체로는 VM 이기 때문에 하이퍼바이저를 포함하고 있다.
- 실제 환경(PC)과 가상 환경(도커)의 관계에서는 Guest OS이다.
- 도커와 컨테이너의 관계에서는 Host OS 인 리눅스가 설치되어 있다. 해당 컨테이너에는 VM Host와는 달리 OS가 설치되어 있지 않다.

## VM
### VM의 정의
> 가상 머신(Virtual Machine, VM)은 물리적 하드웨어 시스템에 구축되어 자체 CPU, 메모리, 네트워크 인터페이스 및 스토리지를 갖추고 가상 컴퓨터 시스템으로 작동하는 가상 환경이다.

### 가상화가 되지 않은 기존의 컴퓨터 구조
- 물리적인 하드웨어에 하나의 OS가 할당되고, 그 위에 Application들이 실행된다.
- 하나의 OS에서 작업하다가 잘못될 경우, 전체 시스템에 장애가 발생하거나 이전환경으로 되돌릴 수 없다.

> ![image.png|300](https://i.imgur.com/N6bZCRq.png)


### 가상화를 한 컴퓨터의 구조
- 물리적인 하드웨어에 여러개의 OS를 할당하여 각각에 리소스를 할당할 수 있다.
- 각각의 VM이 독립되어있기 때문에 하나의 시스템이 다른 시스템에 영향을 주지 않는다.
- 각각의 VM이 OS를 가지고 있기 때문에 OS용량(Windows의 경우 5GB )을 차지한다.
- VMware Virtualization Layer를 구현해주는 소프트웨어는 [[하이퍼바이저]]다.

>![image.png|300](https://i.imgur.com/jsOht80.png)

## 컨테이너와 VM의 차이점
- VM은 각각의 독립된 시스템에 OS가 있지만 컨테이너에는 OS가 없다.
- VM은 하나씩 늘 때 마다 OS를 위한 자원 할당을 해야하지만([[하이퍼바이저]]), 도커는 어플리케이션을 구동하는데 필요한 모든 패키지만 있으면 컨테이너를 구동할 수 있다.

## 하이퍼바이저
### 역할
- 하드웨어 위에서 가상 머신을 생성한다.
- 필요한 만큼 자원을 할당한다.
- 가상 머신들의 요청을 처리해주는 등 가상화를 도와줄 매니저 역할을 한다.
- 가상 머신 매니저(Virtual Machine Manager)라고 부른다.
- 물리 하드웨어와 가상 머신의 영역 사이에서 인터페이스 역할을 한다.
- 하이퍼바이저는 위치에 따라 유형1 하이퍼바이저, 유형2 하이퍼바이저로 구분된다.

### 유형 1 하이퍼바이저(Bare-Metal Hypervisor)

>유형 1 하이퍼바이저 구조도
>![image.png|300](https://i.imgur.com/RGn9IqK.png)

- 하드웨어 위에서 직접 구동되어 게스트 OS를 관리한다.
- 하드웨어에 OS대신 하이퍼바이저를 설치하는 것이다.
- 따라서 호스트OS가 존재하지 않는다.
- 게스트OS는 호스트OS를 거치지 않기 때문에 오버헤드가 적다.
- 각 게스트의 OS문제가 다른 게스트OS에 영향을 주지 않는다.
- VM들에 대한 자체적인 관리 기능이 없어, VM 관리를 위한 컴퓨터나 콘솔이 별개로 필요하다.
- `VMware의 ESXi`, `Citrix의 Xen`, `Microsoft의 Hyper-V` 등이 대표적인 유형 1 하이퍼바이저이다.
- 유형 1 하이퍼바이저는 기업용 데이터 센터에서 일반적으로 사용된다.


### 유형 2 하이퍼바이저(Hosted Hypervisor)

> 유형 2 하이퍼바이저 구조도
> ![image.png|300](https://i.imgur.com/HdU0Qey.png)

- Host OS를 갖는 하이퍼바이저다.
- 하드웨어에 호스트 OS가 이미 설치되어 있고, 하이퍼바이저는 OS 위에서 소프트웨어로서 동작한다.
- 기존 시스템 위에서 쉽게 사용할 수 있다는 것이 유형 2의 가장 큰 장점이다.
- 게스트 OS가 하드웨어 위에 3번째 수준으로 실행되기 때문에 오버헤드가 크다.
- 호스트 OS의 문제가 전체 게스트 OS에 영향을 줄 수 있다.
-  `VMware의 Workstation`, `Oracle의 VirtualBox` 등의 소프트웨어가 유형 2 하이퍼바이저에 해당된다.
- 유형 2 하이퍼바이저는 개인 컴퓨터에서 VM을 사용하고자 할 때 일반적으로 사용하는 유형이다.(1학년때 컴입문 리눅스 실습때 사용한 VMware)

## 도커 이미지
### 개념
- 컨테이너 생성의 기반이 되는 패키지이다.
- [[도커 허브]]에 이미지를 업로드, 다운로드 받을 수 있다.
- [[Layer구조]]로 이루어져 있다.

### 만드는 방법
- 컨테이너에서 `commit`을 해서 컨테이너 기준으로 `image`를 만들 수 있다.
- 도커 파일을 빌드해서 `image`를 만들 수 있다.

### 도커 이미지의 Layer 구조
- 이미지 Layer는 파일시스템의 변경사항을 캡처하는 단위이다.
- Dockerfile을 읽어들여, **파일 시스템에 변화를 주는 커맨드**마다 새로운 이미지 레이어를 만든다. 
- UnionFS(Union File System)구조이다.
	- 두 개 이상의 디렉토리를 하나의 디렉토리인 것처럼 합쳐서 보여주는 시스템
- 파일 시스템에 변화를 주지 않는 무의미한 커맨드의 반복이나, echo와 같이 stdout을 발생시키는 커맨드, ‘LABEL’ 과 같은 메타 데이터를 수정하는 명령들은 새로운 이미지를 만들지 않는다.
- 메타 데이터의 경우 이미지의 별도 메타 데이터 저장 공간에 JSON 형식으로 저장된다.
- 도커는 이미지를 만들 때 하나의 단일 스냅샷으로 만드는 것이 아닌, 여러 개의 계층(layer)을 가진 다수의 스냅샷으로 나누어 저장한다.
- 여러 이미지 파일들을 관리할 때, 이미지들에서 중복되는 영역을 하나의 레이어를 통해 관리하여 공간 & 시간 효율을 얻기 위함이다.
- [[컨테이너 레이어]]에도 `Layer`개념이 적용된다.

## 도커 파일
### 도커파일 명령어 종류
#### FROM
- 베이스 이미지(Base image)를 지정하는 지시어다.
- 베이스 이미지와 태그를 지정하면 registry 에서 해당 이미지를 땡겨오게(pull) 된다.
- 명령어 예시: `FROM ubuntu:18.04`
#### RUN
- command 를 실행(run)하여 새 이미지에 포함시키는 역할
- 실행 시점: 이미지를 비드할 때
- 컨테이너에 꼭 필요한 소프트웨어, 라이브러리, 폴더 등이 필요한 경우 그것을 생성하는 명령어.
- Shell Form, Exec Form으로 작성 가능하다.
	- Shell Form(터미널 명령어와 유사): `RUN /bin/bash -c 'echo hello'`
	- Exec Form: `RUN ["/bin/bash", "-c", "echo hello"]
#### CMD
- 컨테이너가 시작될 때 실행할 커멘드
- 실행시점: 컨테이너를 시작할 때
- Shell Form, Exec Form으로 작성 가능하다.
- CMD는 도커 파일의 맨 마지막 CMD명령어만 유효하다.
- shell form 은 환경변수 인식이 가능하고 exec form 은 불가능하다.
#### ENTRYPOINT
- 컨테이너 시작 시 실행될 command 를 지정
- Shell Form, Exec Form으로 작성 가능하다.
- ENTRYPOINT는 도커 파일의 맨 마지막 ENTRYPOINT명령어만 유효하다.
- [ENTRYPOINT와 CMD의 차이](https://velog.io/@inhalin/ENTRYPOINT-CMD-%EC%B0%A8%EC%9D%B4)
#### LABEL
- key-value 형식으로 작성된 메타데이터를 이미지에 추가한다.
- ex)`LABEL "toramkey"="toramval"`
- `Image Label`의 버전 확인: docker image inspect --format=myimage
#### ENV
- 환경변수를 설정하는 지시어이다.
- `ENV <key>=<value> <key>=<value> <key>=<value> ...`
#### EXPOSE
- 컨테이너가 실행될 때 컨테이너로 들어오는 트래픽을 특정 포트(port) 로 받아들일 수 있도록(listen) 지정하는 역할을 한다.
- 형식: `EXPOSE <포트>/<프로토콜>`
- 예시: `EXPOSE 80/udp`
#### COPY
- Host 내에 있는 파일 또는 디렉토리를 컨테이너의 파일시스템으로 복사.
- 형식: `COPY [--chown=<user>:<group>] <src>... <dest>`
- 예시: `COPY [--chown=<user>:<group>] ["<src>",... "<dest>"]`
#### ADD
- 파일 또는 디렉토리를 컨테이너로 복사한다.
- 형식: `ADD [--chown=<user>:<group>] <src>... <dest>
- 예시1: `ADD [--chown=<user>:<group>] ["<src>",... "<dest>"]`
- 예시2: `ADD http://example.com/foobar /toramko/
- ADD는 COPY와 다르게 Host 내에 있는 파일 외에도 경로(URL)를 지정하여 remote 파일/디렉토리를 복사해올 수 있다.
#### USER
- 컨테이너 안에서 명령을 실행할 유저명, 유저그룹을 설정한다.
- 기본적으로 컨테이너는 root 계정으로 실행되는데 이를 사용자계정 등으로 변경하기 위함이다.
- 형식: `USER <user>[:<group>]`
- 예시: `USER <UID>[:<GID>]`
#### WORKDIR
- 작업 디렉토리(Working Directory) 를 설정한다.
- 리눅스의 cd 명령어와 유사하나, 이동하려는 디렉토리가 존재하지 않을 경우 해당 디렉토리를 생성하여 이동한다.
- 예시: `WORKDIR /path/to/workdir`
#### VOLUME
-  컨테이너 내의 특정 디렉토리를 컨테이너 외부 경로에 마운트(mount) 시켜주는 명령어이다.
- 컨테이너 내부 데이터는 보통 컨테이너가 삭제되면 날아가버린다. 이를 막기 위해, 즉 컨테이너가 삭제되어도 데이터가 보존될 수 있도록 컨테이너 내부 경로를 외부로 연결시켜주는 것이 마운트 작업이다.
- 연결된 외부 경로에 데이터가 쌓이면서 영구 보존이 가능해진다.
- 예시: `VOLUME ["/data"]`

## 도커 명령어
### 도커
- `docker -v`: 도커 엔진 버전 확인

### 이미지 관련 명령어
- `docker build -t [이미지명]:[태그명] [dockerfile경로]`: `Dockerfile`을 이용해서 `image`를 생성한다.
- `docker image rm [이미지ID or 이름]`: 도커 단일 이미지 삭제
- `docker rmi [옵션] [이미지ID or 이름]`: 모든 도커 이미지 삭제(컨테이너가 있어서 삭제가 안될 시 `-f`옵션을 통해서 삭제 가능
- `docker images`: 도커 모든 이미지 조회
- `docker image ls`: 현재 이미지 목록 확인
- `docker search [이미지 이름]`: 도커 허브에서 이미지 검색
- `docker image pull [이미지명]:[태그]`: Dockerhub에서 이미지 가져오기
- `docker container commit [컨테이너 이름] [커밋내용]`: 구동한 Docker Container를 commit(변경사항을 이미지로)

### 컨테이너 관련 명령어
- `sudo docker ps`: 현재 실행중인 컨테이너 확인(실행중인것만)
- `sudo docker ps -a`: 현재 실행중인 컨테이너 확인(중지중것 포함)
- `sudo docker stop <컨테이너 이름 or 아이디>`: 실행중인 컨테이너 중지
- `sudo docker rm <컨테이너 이름 or 아이디>`: 실행이 중지된 컨테이너 삭제
	- 실행중인 컨테이너 삭제 불가능
	- 실행중인 컨테이너를 살제하기 위해서는 `-f`옵션 추가
	  `sudo docker rm -f <컨테이너 이름 or 아이디>`
- `sudo docker container prune`: 모든 컨테이너 삭제
- `sudo docker start <컨테이너 이름 or 아이디`: 컨테이너 시작
- `sudo docker restart <컨테이너 이름 or 아이디`: 컨테이너 재시작
- `sudo docker attach <컨테이너 이름 or 아이디`: 현재 실행중인 컨테이너에 접속
- `docker create -i -t --name [컨테이너 이름] [이미지 이름]:[이미지 버전]`: 도커 이미지로 컨테이너 생성
	- `-i`: 상호 입출력을 설정
	- `-t`: tty를 활성화하여 bash 셸을 사용하도록 설정
	- `--name`: 컨테이너의 이름을 지정한다. 명령어를 사용하지 않으면 고유값으로 무작위 16진수 해시값이 지정이 된다.
- `docker run -i -t [이미지이름]:[이미지 버전]`: 이미지로 컨테이너를 실행한다.
	- 이미지가 로컬 도커 엔진에 없을 경우 도커 허브에서 자동으로 이미지를 내려받아서 실행한다.
	- 이미지 버전을 입력하지 않으면 자동으로 latest로 지정된다.
	- 컨테이너 실행 후 자동으로 접속한다.
- `exit`: 컨테이너에서 빠져나오면서 컨테이너를 정지시킨다.
- `Ctrl + D`: 컨테이너에서 빠져나오면서 컨테이너를 정지시킨다.
- `Ctrl + P or Q`: 컨테이너의 셸에서만 빠져나온다. (컨테이너 정지 X)

### run, create, start명령어의 차이
>![[Pasted image 20240721142911.png]]
#### run
- pull → create → start순서로 실행한 후 attach가 가능하다면 컨테이너 내부에 접속한다.
#### create
- pull → create순서로 컨테이너를 생성한다.

### 컨테이너를 외부에 노출
- 컨테이너는 vm과 마찬가지로 가상 IP주소를 부여받는다.
- 기본적으로 도커 컨테이너에 172.17.0.x의 IP를 순차적으로 할당한다.
- 컨테이너를 생성할 때 다른 설정을 하지 않았으면 외부에서 컨테이너에 접근할 수 없으며, 도커가 설치된 호스트에서만 접근할 수 있다.(예외로 Docker Desktop for Mac에서는 호스트에서 컨테이너 IP로의 접근이 불가능하다.)
- 외부에 컨테이너의 애플리케이션을 노출하기 위해서는 `eth0`의 IP와 포트를 호스트의 IP와 포트에 바인딩해야 한다.
- `docker run -i -t -p [호스트의 포트]:[컨테이너의 포트] [이미지 이름]:[이미지 버전]`